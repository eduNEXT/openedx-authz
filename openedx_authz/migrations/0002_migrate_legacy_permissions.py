# Generated by Django 5.2.7 on 2025-11-03 20:39

import logging

from django.db import migrations

from openedx_authz.api.users import assign_role_to_user_in_scope, batch_assign_role_to_users_in_scope
from openedx_authz.constants.roles import LIBRARY_ADMIN, LIBRARY_AUTHOR, LIBRARY_USER

logger = logging.getLogger(__name__)


def migrate_legacy_permissions(apps, schema_editor):
    """
    Migrate legacy permission data to the new Casbin-based authorization model.
    This function reads legacy permissions from the ContentLibraryPermission model
    and assigns equivalent roles in the new authorization system.

    The old Library permissions are stored in the ContentLibraryPermission model, it consists of the following columns:

    - library: FK to ContentLibrary
    - user: optional FK to User
    - group: optional FK to Group
    - access_level: 'admin' | 'author' | 'read'

    In the new Authz model, this would roughly translate to:

    - library: scope
    - user: subject
    - access_level: role

    Now, we don't have an equivalent concept to "Group", for this we will go through the users in the group and assign
    roles independently.
    """
    # ContentLibraryPermission model from the content_libraries app, here is where the legacy permissions are stored
    try:
        ContentLibraryPermission = apps.get_model(
            'content_libraries', 'ContentLibraryPermission')
    except LookupError:
        # Don't run the migration where the content_libraries app is not installed, like during development.
        logger.warning(
            "ContentLibraryPermission model not found. Skipping migration.")
        return

    legacy_permissions = ContentLibraryPermission.objects.select_related(
        'library', 'library__org', 'user', 'group'
    ).all()

    for permission in legacy_permissions:
        # Migrate the permission to the new model

        # Derive equivalent role based on access level
        role = LIBRARY_USER
        if permission.access_level == 'admin':
            role = LIBRARY_ADMIN
        elif permission.access_level == 'author':
            role = LIBRARY_AUTHOR
        elif permission.access_level == 'read':
            role = LIBRARY_USER
        else:
            # This should not happen, log and skip
            # TODO: Should we fail here instead?
            logger.warning(
                f"Unknown access level: {permission.access_level} for User: {permission.user}")
            continue

        # Generating scope based on library identifier
        scope = f"lib:{permission.library.org.name}:{permission.library.slug}"

        if permission.group:
            # Permission applied to a group
            users = [user.username for user in permission.group.user_set.all()]
            logger.info(
                f"Migrating permissions for Users: {users} in Group: {permission.group.name} to Role: {role.external_key} in Scope: {scope}"
            )
            batch_assign_role_to_users_in_scope(
                users=users,
                role_external_key=role.external_key,
                scope_external_key=scope
            )
        else:
            # Permission applied to individual user
            logger.info(
                f"Migrating permission for User: {permission.user.username} to Role: {role.external_key} in Scope: {scope}"
            )

            assign_role_to_user_in_scope(
                user_external_key=permission.user.username,
                role_external_key=role.external_key,
                scope_external_key=scope
            )


class Migration(migrations.Migration):

    dependencies = [
        ('openedx_authz', '0001_add_casbin_dependency'),
    ]

    operations = [
        migrations.RunPython(migrate_legacy_permissions),
    ]
