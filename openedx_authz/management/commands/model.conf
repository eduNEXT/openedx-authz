############################################
# Open edX AuthZ — Casbin Model Configuration
#
# This model supports:
# - Scoped role assignments (user roles tied to specific contexts)
# - Action grouping (manage → read/write/delete to reduce duplication)
# - System-wide roles (global scope "*" applies everywhere)
# - Granular permissions (exact resources) and broad permissions (org-level)
# - Negative rules (deny overrides allow for exceptions)
# - Namespace support (course:*, lib:*, org:*, etc.)
# - Extensibility (new resource types just need new namespaces)
#
# NOT handled here (deferred to application):
# - Resource grouping/containment (app resolves parent-child relationships)
# - Role inheritance across scopes (app checks multiple scopes explicitly)
# - Object lifecycle consistency (app handles cleanup on delete)
############################################

[request_definition]
# Request format: subject, action, object, scope
#
# sub   = subject/principal with namespace (e.g., "user:alice", "service:lms")
# act   = action with namespace (e.g., "act:read", "act:manage", "act:edit-courses")
# obj   = object/resource with namespace (e.g., "course:course-v1:OpenedX+Demo+2024", "lib:math-basics", "org:OpenedX")
# scope = authorization scope context (e.g., "org:OpenedX", "lib:math-basics", "*" for global)
#
# SCOPE SEMANTICS:
# - Scope determines which role assignments are considered
# - "*"                    = global scope (system-wide roles)
# - "org:OpenedX"          = organization-scoped roles
# - "course:course-v1:..." = course-scoped roles
#
# - Application must provide appropriate scope based on business logic
r = sub, act, obj, scope

[policy_definition]
# Policy format: subject, action, object, effect
#
# sub = role or direct user with namespace (e.g., "role:org_admin", "user:bob")
# act = action identifier (e.g., "act:manage", "act:read", "act:edit-courses"). Uses g2 relation for action grouping.
# obj = object selector - supports multiple patterns via keyMatch:
#      - Exact ID: "course:course-v1:OpenedX+Demo+2024"
#      - Namespace wildcard: "course:*" (matches all courses)
#      - Prefix patterns: "course:course-v1:OpenedX+*" (matches all OpenedX courses)
#      - Scope targets: "org:OpenedX" (organization itself)
# eft = "allow" or "deny" (deny overrides allow for exceptions)
p = sub, act, obj, eft

[role_definition]
# g: Role assignments with scope
# Format: user/subject, role, scope
#
# Examples:
# g, user:alice, role:org_admin, org:OpenedX                 # Alice is org admin for OpenedX
# g, user:bob, role:course_instructor, course:course-v1:...  # Bob is instructor for specific course
# g, user:carol, role:platform_admin, *                      # Carol is global platform admin
# g, service:lms, role:system_service, *                     # LMS service has system-wide access
#
# Role hierarchy (optional):
# g, role:org_admin, role:org_editor, org:OpenedX            # org_admin inherits org_editor permissions
g = _, _, _

# g2: Action grouping and implications
# Maps high-level actions to specific actions to reduce policy duplication
#
# Examples:
# g2, act:manage, act:read        # manage implies read
# g2, act:manage, act:edit        # manage implies edit
# g2, act:manage, act:write       # manage implies write
# g2, act:manage, act:delete      # manage implies delete
# g2, act:edit-courses, act:read  # edit-courses implies read (for resource grouping)
# g2, act:edit-courses, act:write # edit-courses implies write
g2 = _, _

[policy_effect]
# Deny-override policy: allow if any rule allows AND no rule denies
# This enables negative rules/exceptions (e.g., "manage all courses except course Z")
#
# Evaluation order:
# 1. Check if any policy grants allow
# 2. Check if any policy specifies deny
# 3. If deny found, result is deny (exceptions win)
# 4. If allow found and no deny, result is allow
# 5. If no matches, result is deny (default secure)
e = some(where (p.eft == allow)) && !some(where (p.eft == deny))

[matchers]
# Authorization matching logic
#
# SCOPE MATCHING:
# - g(r.sub, p.sub, r.scope): check if subject has role in requested scope
# - g(r.sub, p.sub, "*"): check if subject has global role (applies everywhere)
#
# OBJECT MATCHING:
# - keyMatch(r.obj, p.obj): pattern-based object matching
#   Supports wildcards like "course:*" matching "course:course-v1:OpenedX+Demo+2024"
#   Also supports exact matches when no wildcards are used
#
# ACTION MATCHING:
# - g2(p.act, r.act): policy action implies requested action via action grouping
#   Allows high-level actions (manage) to grant specific actions (read/write/delete)
#
# All conditions must be true for a policy to match:
# 1. Subject must have the required role in scope OR globally
# 2. Object must match the policy object pattern
# 3. Policy action must imply the requested action
m = (g(r.sub, p.sub, r.scope) || g(r.sub, p.sub, "*")) && keyMatch(r.obj, p.obj) && g2(p.act, r.act)
