############################################
# Open edX AuthZ — Casbin Model Configuration
#
# This model supports:
# - Scoped role assignments (user roles tied to specific contexts)
# - Action grouping (manage → read/write/delete to reduce duplication)
# - System-wide roles (global scope "*" applies everywhere)
# - Granular permissions (exact resources) and broad permissions (org-level)
# - Negative rules (deny overrides allow for exceptions)
# - Namespace support (course-v1:*, lib:*, org:*, etc.)
# - Regex support for complex resource ID patterns
# - Extensibility (new resource types just need new namespaces)
#
# NOT handled here (deferred to application):
# - Resource grouping/containment (app resolves parent-child relationships)
# - Role inheritance across scopes (app checks multiple scopes explicitly)
# - Object lifecycle consistency (app handles cleanup on delete)
############################################

[request_definition]
# Request format: subject, action, object, scope
#
# sub: subject/principal with namespace (e.g., "user:alice", "service:lms")
# act: action with namespace (e.g., "act:read", "act:manage", "act:edit-courses")
# obj: object/resource with namespace (e.g., "course:course-v1:OpenedX+Demo+2024", "lib:math-basics", "org:OpenedX")
# scope: authorization scope context (e.g., "org:OpenedX", "lib:math-basics", "*" for global)
#
# SCOPE SEMANTICS:
# - scope determines which role assignments are considered
# - "*" = global scope (system-wide roles)
# - "org:OpenedX" = organization-scoped roles
# - "course:course-v1:..." = course-scoped roles
# - Application must provide appropriate scope based on business logic
r = sub, act, obj, scope

[policy_definition]
# Policy format: subject, action, object, effect
#
# sub: role or direct user with namespace (e.g., "role:org_admin", "user:bob")
# act: action or action pattern (e.g., "act:manage", "act:edit-*", "^act:(read|write)$")
# obj: object selector - supports multiple patterns:
#      - Exact ID: "course-v1:OpenedX+Demo+2024"
#      - Namespace wildcard: "course-v1:*" (all courses)
#      - Regex: "^course-v1:OpenedX\\+.*" (all OpenedX courses)
#      - Scope targets: "org:OpenedX" (organization itself)
# eft: "allow" or "deny" (deny always wins for negative rules/exceptions)
p = sub, act, obj, eft

[role_definition]
# g: Role assignments with scope
# Format: user/subject, role, scope
#
# Examples:
# g, user:alice, role:org_admin, org:OpenedX         # Alice is org admin for OpenedX
# g, user:bob, role:course_instructor, course-v1:... # Bob is instructor for specific course
# g, user:carol, role:platform_admin, *              # Carol is global platform admin
# g, service:lms, role:system_service, *             # LMS service has system-wide access
#
# Role hierarchy (optional):
# g, role:org_admin, role:org_editor, org:OpenedX    # org_admin inherits org_editor permissions
g = _, _, _

# g2: Action grouping and implications
# Maps high-level actions to specific actions to reduce policy duplication
#
# Examples:
# g2, act:manage, act:read        # manage implies read
# g2, act:manage, act:write       # manage implies write
# g2, act:manage, act:delete      # manage implies delete
# g2, act:edit-courses, act:read  # edit-courses implies read (for resource grouping)
# g2, act:edit-courses, act:write # edit-courses implies write
g2 = _, _

[policy_effect]
# Deny-override policy: allow if any rule allows AND no rule denies
# This enables negative rules/exceptions (e.g., "manage all courses except course Z")
#
# Evaluation order:
# 1. Check if any policy grants allow
# 2. Check if any policy specifies deny
# 3. If deny found, result is deny (exceptions win)
# 4. If allow found and no deny, result is allow
# 5. If no matches, result is deny (default secure)
e = some(where (p.eft == allow)) && !some(where (p.eft == deny))

[matchers]
# Authorization matching logic
#
# SCOPE MATCHING:
# - g(r.sub, p.sub, r.scope): check if subject has role in requested scope
# - g(r.sub, p.sub, "*"): check if subject has global role
#
# OBJECT MATCHING:
# - r.obj == p.obj: exact object match
# - regexMatch(r.obj, p.obj): regex pattern matching for complex ID patterns
#
# ACTION MATCHING:
# - r.act == p.act: exact action match
# - regexMatch(r.act, p.act): regex action patterns (e.g., "^act:(read|write)$")
# - g2(p.act, r.act): policy action implies requested action via grouping
#
# All conditions must be true for a policy to match
m = (g(r.sub, p.sub, r.scope) || g(r.sub, p.sub, "*"))
    && (r.obj == p.obj || regexMatch(r.obj, p.obj))
    && (r.act == p.act || regexMatch(r.act, p.act) || g2(p.act, r.act))
