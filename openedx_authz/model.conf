# ============================================================
# Proposal 1: Explicit grouping with g2 (namespaces only in policy)
# Real object IDs stay raw (e.g., "course-v1:OpenedX+DemoX+DemoCourse").
# Policy uses readable namespaces: org:*, course:*, lib:*, report:*, asset:*.
# ============================================================

[request_definition]
r = sub, obj, act, scope
# r.sub  = "user:maria"
# r.obj  = raw object ID, e.g., "course-v1:OpenedX+DemoX+DemoCourse" or "report-123"
# r.act  = "read" | "write" | "delete"
# r.scope= container label (e.g., "org:OpenedX") or "*" for global

[policy_definition]
p = sub, obj, act, eft
# p.sub = role label (e.g., "role:admin", "role:editor")
# p.obj = one of:
#   • container label: "org:OpenedX", "course:course-v1:...", "lib:OpenedX+DemoX+LibA"
#   • type-wide label: "course:*", "lib:*", "report:*", "asset:*"   <-- NAMESPACE ONLY
#   • concrete raw id: e.g., "course-v1:OpenedX+DemoX+DemoCourse", "report-123" (no prefix)
# p.act = regex grouping, e.g., "^(read|write|delete)$"
# p.eft = "allow" | "deny"

[role_definition]
g = _, _, _
# g, user:maria, role:admin, *
# g, user:bob,   role:editor, org:OpenedX
# g, user:carol, role:editor, course:course-v1:OpenedX+DemoX+DemoCourse

g2 = _, _
# g2 encodes CONTAINMENT edges (child -> parent), both children and parents can be:
#  • child: raw object ID    (e.g., "report-123", "course-v1:OpenedX+DemoX+DemoCourse")
#  • parent: container label (e.g., "course:course-v1:...", "org:OpenedX", "lib:...")
# Examples:
# g2, course-v1:OpenedX+DemoX+DemoCourse, org:DemoX
# g2, report-123,                             course:course-v1:OpenedX+DemoX+DemoCourse
# g2, asset-9,                                lib:OpenedX:DemoX:LibA
# Keep g2 fresh with lifecycle events.

[policy_effect]
e = some(where (p.eft == allow)) && !some(where (p.eft == deny))

[matchers]
# We use ONE small helper:
#   type_match(r.obj, p.obj) -> bool
#     - If p.obj == "<type>:*" (e.g., "course:*"): return classify(r.obj) == "<type>"
#     - Else: return false (type_match only handles type-wide labels)
#   ("classify" is your tiny mapper: raw ID → {"course","lib","report","asset",...})

# (A) concrete object match: policy lists raw ID exactly
# (B) type-wide match: policy says "course:*", "lib:*", ...
# (C) container match: policy targets a container; object must be inside it (via g2, possibly multiple hops)

m = ( g(r.sub, p.sub, r.scope) || g(r.sub, p.sub, "*") ) && (( r.obj == p.obj ) || type_match(r.obj, p.obj) || g2(r.obj, p.obj)) && ( g(r.sub, p.sub, "*") || g2(r.obj, r.scope) ) && regexMatch(r.act, p.act)
