############################################
# Open edX AuthZ — Casbin Model Configuration
#
# This model supports:
# - Scoped role assignments (user roles tied to specific contexts)
# - Action grouping (manage → read/write/delete to reduce duplication)
# - System-wide roles (global scope "*" applies everywhere)
# - Scope-based permissions (authorization based on context, not specific objects)
# - Negative rules (deny overrides allow for exceptions)
# - Namespace support (course-v1:*, lib:*, org:*, etc.)
# - Extensibility (new resource types only require new scope namespaces)
#
# DESIGN PRINCIPLE:
# - Authorization is scope-based, not object-based
# - Each request is explicitly scoped (course, org, global, etc.)
# - Permissions are granted within scopes, eliminating need for object matching
# - Containment relationships are handled by the application layer
#
# NOT handled here (deferred to application):
# - Resource grouping/containment (app resolves parent-child relationships)
# - Role inheritance across scopes (app checks multiple scopes explicitly)
# - Object lifecycle consistency (app handles cleanup on delete)
############################################

[request_definition]
# Request format: subject, action, scope
#
# sub   = subject/principal with namespace (e.g., "user:alice", "service:lms")
# act   = action with namespace (e.g., "act:read", "act:manage", "act:edit-courses")
# scope = authorization scope context (e.g., "org:OpenedX", "course-v1:...", "*" for global)
#
# SCOPE SEMANTICS:
# - Scope determines the authorization context and which role assignments apply
# - "*"                    = global scope (system-wide roles apply everywhere)
# - "org:OpenedX"          = organization-scoped roles (apply within OpenedX org)
# - "course-v1:..." = course-scoped roles (apply within specific course)
#
# Application must provide appropriate scope based on business logic.
r = sub, act, scope

[policy_definition]
# Policy format: subject, action, scope, effect
#
# sub   = role or user with namespace (e.g., "role:org_admin", "user:bob")
# act   = action identifier (e.g., "act:manage", "act:read", "act:edit-courses"). Uses g2 relation for action grouping.
# scope = scope where policy applies (e.g., "*", "org:OpenedX", "course-v1:...")
# eft   = "allow" or "deny" (deny overrides allow for exceptions)
p = sub, act, scope, eft

[role_definition]
# g: Role assignments (without scope)
# Format: user/subject, role
#
# This is a simplified role assignment where users are assigned roles globally,
# without being tied to specific scopes. All role assignments apply system-wide.
#
# Examples:
# g, user:alice, role:org_admin                 # Alice is org admin
# g, user:bob, role:course_instructor           # Bob is course instructor
# g, user:carol, role:platform_admin            # Carol is platform admin
# g, service:lms, role:system_service           # LMS service has system-wide access
#
# Role hierarchy (optional):
# g, role:org_admin, role:org_editor            # org_admin inherits org_editor permissions
#
# NOTE: Without scope in role assignments, authorization control must rely entirely
# on policy definitions (p) to restrict access to appropriate scopes/contexts.
g = _, _

# g2: Action grouping and implications
# Maps high-level actions to specific actions to reduce policy duplication
#
# Examples:
# g2, act:manage, act:edit        # manage implies edit
# g2, act:manage, act:delete      # manage implies delete
# g2, act:edit-courses, act:read  # edit-courses implies read (for resource access)
# g2, act:edit-courses, act:write # edit-courses implies write (for resource modification)
g2 = _, _

[policy_effect]
# Deny-override policy: allow if any rule allows AND no rule denies
# This enables negative rules/exceptions (e.g., "manage all courses except course Z")
#
# Evaluation order:
# 1. Check if any policy grants allow
# 2. Check if any policy specifies deny
# 3. If deny found, result is deny (exceptions win)
# 4. If allow found and no deny, result is allow
# 5. If no matches, result is deny (default secure)
e = some(where (p.eft == allow)) && !some(where (p.eft == deny))

[matchers]
# Authorization matching logic
#
# SUBJECT MATCHING:
# - g(r.sub, p.sub): check if request subject matches policy subject (role assignment)
#   This handles user-to-role mappings defined in the role_definition section
#
# ACTION MATCHING:
# - g2(p.act, r.act): policy action implies requested action via grouping
#   Allows high-level actions (manage) to grant specific actions (read/write/delete)
#
# SCOPE MATCHING:
# - keyMatch(r.scope, p.scope): check if request scope matches policy scope
#   Supports wildcard matching (e.g., "*" matches any scope)
#   Enables hierarchical scope matching for nested authorization contexts
#
# All conditions must be true for a policy to match:
# 1. Subject must have the required role (via role assignment)
# 2. Policy action must imply the requested action (via action grouping)
# 3. Request scope must match the policy scope (with wildcard support)
#
# SCOPE-BASED AUTHORIZATION:
# The matcher uses keyMatch for flexible scope matching, allowing policies
# to apply to specific scopes (org:OpenedX) or globally (*), providing
# fine-grained control over authorization contexts.
m = g(r.sub, p.sub) && g2(p.act, r.act) && keyMatch(r.scope, p.scope)
